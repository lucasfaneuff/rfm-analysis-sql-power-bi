{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Customer Segmentation: Cleaning, EDA & RFM Notebook\n",
    "This notebook demonstrates full data cleaning, exploratory analysis, and RFM segmentation logic based on uploaded SQL workflows."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Import Libraries"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "import pandas as pd\n",
    "import numpy as np"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Load Data\n",
    "*(Replace file paths with your actual CSVs before running)*"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "customer = pd.read_csv('customer.csv')\n",
    "sales = pd.read_csv('sales.csv')\n",
    "customer.head(), sales.head()"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Data Cleaning Steps (Based on SQL Logic)"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Format date_joined\n",
    "customer['date_joined'] = pd.to_datetime(customer['date_joined'], errors='coerce')\n",
    "\n",
    "# Remove customer_ids in sales not found in customer table\n",
    "sales = sales[sales['customer_id'].isin(customer['customer_id'])]"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Create total_price and total_orders\n",
    "sales['total_price'] = sales[['wine_sales','fruit_sales','meat_sales','fish_sales','sweet_sales','gold_sales']].sum(axis=1)\n",
    "sales['total_orders'] = sales[['web_orders','catalog_orders','store_orders']].sum(axis=1)\n",
    "# Remove customers with 0 orders\n",
    "sales = sales[sales['total_orders'] > 0]"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Merge Customer & Sales Tables"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "df = pd.merge(sales, customer, on='customer_id', how='left')\n",
    "df.head()"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Exploratory Data Analysis (EDA)"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "df.describe()"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Key Metrics"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "metrics = {\n",
    "    'Total Monetary': df['total_price'].sum(),\n",
    "    'Avg Monetary': df['total_price'].mean(),\n",
    "    'Max Monetary': df['total_price'].max(),\n",
    "    'Min Monetary': df['total_price'].min(),\n",
    "    'Total Frequency': df['total_orders'].sum(),\n",
    "    'Avg Frequency': df['total_orders'].mean(),\n",
    "    'Total Customers': df['customer_id'].nunique()\n",
    "}\n",
    "metrics"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. RFM Scoring (Replicates SQL Logic)"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Assign NTILE bins like SQL\n",
    "df['r_score'] = pd.qcut(df['recency'].rank(method='first', ascending=False), 5, labels=[1,2,3,4,5]).astype(int)\n",
    "df['f_score'] = pd.qcut(df['total_orders'], 5, labels=[1,2,3,4,5]).astype(int)\n",
    "df['m_score'] = pd.qcut(df['total_price'], 5, labels=[1,2,3,4,5]).astype(int)\n",
    "df['rfm_score'] = df['r_score'].astype(str) + df['f_score'].astype(str) + df['m_score'].astype(str)"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Segment Assignment (Based on SQL CASE Logic)"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "def assign_segment(row):\n",
    "    r,f,m = row['r_score'], row['f_score'], row['m_score']\n",
    "    if r >= 3 and f >= 4 and m >= 3: return 'Loyalist'\n",
    "    if r >= 4 and f in [2,3] and m in [2,3,4]: return 'Potential Loyal'\n",
    "    if r >= 4 and (f==1 or m==1): return 'New Customer'\n",
    "    if r == 3 and f in [2,3] and m in [2,3,4]: return 'Growing'\n",
    "    if r == 3 and f <= 2 and m <= 2: return 'Promising'\n",
    "    if f == 5 and m == 5 and r <= 3: return 'Est. Spender'\n",
    "    if m == 5 and f <= 3: return 'Big Spender'\n",
    "    if r == 2 and (f >= 4 or m >= 4): return 'Loyal (At Risk)'\n",
    "    if r == 2 and f <= 3 and m <= 3: return 'Customer At Risk'\n",
    "    if r == 1: return 'Lost'\n",
    "    return 'Misc'\n",
    "\n",
    "df['rfm_segmenting'] = df.apply(assign_segment, axis=1)"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 8. Final Output"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "df.to_csv('rfm_output.csv', index=False)\n",
    "df.head()"
   ],
   "execution_count": null,
   "outputs": []
  }
 ],
 "metadata": {
  "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"},
  "language_info": {"name": "python"}
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
